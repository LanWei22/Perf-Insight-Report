<!DOCTYPE HTML>

<link rel="import" href="/perf_insights/function_handle.html">
<link rel="import" href="/perf_insights/mappers/thread_grouping.html">
<link rel="import" href="/tracing/base/range.html">
<link rel="import" href="/tracing/value/histogram.html">
<link rel="import" href="/tracing/value/unit.html">

<script>
'use strict';

tr.exportTo('pi.m', function() {

  // Find all async slices whoes name are in the name list, and record the list of slices in time order.
  function getAllAsyncSlices(thread, name) {  
    var result = [];
  	thread.asyncSliceGroup.slices.forEach(function(slice) {
      if (name.indexOf(slice.title) > -1) {
  		result.push(slice);
  	  }
  	});
	result.sort(function(a, b) {return a.start-b.start}); 
  	return result;
  }
  
  // Find all slices of the given name.
  function getAllSlices(thread, name) {  
  	var result = [];
	thread.sliceGroup.slices.forEach(function(slice) {
      if (slice.title.indexOf(name) > -1) {
		result.push(slice);
	  }
	});
	return result;
  }

  function getTouchEventSlices(gestureSlices, touchEventSlices) {  
    var result = [];
    var j = 0;
    for (var i = 0; i < gestureSlices.length; i++) {
      for (; j < touchEventSlices.length; j++) {
      	if (gestureSlices[i].args.data.INPUT_EVENT_LATENCY_ORIGINAL_COMPONENT.time == touchEventSlices[j].args.data.INPUT_EVENT_LATENCY_ORIGINAL_COMPONENT.time) {
          result.push(touchEventSlices[j]);
          break;
        }
      }
    }
   	return result;
  }
  
  function getHandlingTime(model, id) {
  	var handlers = {};
	model.flowEvents.forEach(function(flow) {
	    // Follow the FlowEvent which starts from a touch event until we find its ack.
		if (flow.args.trace_id == id) {
		  var slice = flow.endSlice;
		  var ackSource;
		  while (slice !=null) {
			for (var i = 0; i < slice.ancestorSlices.length; i++) {
			  if (slice.ancestorSlices[i].title.indexOf('InputRouterImpl::ProcessInputEventAck') > -1) {
			  	// console.log(slice.ancestorSlices[i].title + ' ' + slice.ancestorSlices[i].args.type + ' ' + slice.ancestorSlices[i].args.ack + ' ' + ackSource + ' ' + slice.ancestorSlices[i].start);
				if (ackSource == 'CrRendererMain') {
					console.log('ack return ' + slice.ancestorSlices[i].title);
					return slice.ancestorSlices[i].title;
				}
	            
			  }
			}
			
			// Find where sends the ack, we only care about ack from renderer.
			ackSource = slice.parentContainer.name;
			if (slice.outFlowEvents[0] != null)
			  slice = slice.outFlowEvents[0].endSlice;
			else
			  slice = null;
		  }
		}
	});
	console.log('return null');
  }
  
  function allBlockingTimeFlowEventMapFunction(model) {
  	var touchWithAck = [];
  	var browserThread = model.findAllThreadsNamed('CrBrowserMain');
	if (browserThread.length == 1) {
	  var gestures = ['InputLatency::GestureTapDown', 'InputLatency::GestureScrollBegin'];
	  var gestureSlices = getAllAsyncSlices(browserThread[0], gestures);
	  var touchEvent = ['InputLatency::TouchStart', 'InputLatency::TouchMove'];
	  var touchEventSlices = getAllAsyncSlices(browserThread[0], touchEvent);
      var touchslices = getTouchEventSlices(gestureSlices, touchEventSlices);
	  console.log(touchslices.length);
  	  for (var i = 0; i < touchslices.length; i++) {
		console.log(touchslices[i].title + ' ' + touchslices[i].args.data.trace_id + ' ' + touchslices[i].start);
		var ack = getHandlingTime(model, touchslices[i].args.data.trace_id);
		console.log('ack ' + ack);
		if (ack != null) {
		  console.log('ack ' + ack.args.type + ' ' + ack.args.ack);
    	  touchWithAck.push({touch: touchslices[i], ack: ack});
		}
	  }
	}
  	return touchWithAck;
  }

  return {
    allBlockingTimeFlowEventMapFunction: allBlockingTimeFlowEventMapFunction
  };
});
</script>

