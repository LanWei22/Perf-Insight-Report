<!DOCTYPE HTML>

<link rel="import" href="/perf_insights/function_handle.html">
<link rel="import" href="/perf_insights/mappers/thread_grouping.html">
<link rel="import" href="/tracing/base/range.html">
<link rel="import" href="/tracing/value/histogram.html">
<link rel="import" href="/tracing/value/unit.html">

<script>
'use strict';

tr.exportTo('pi.m', function() {

  // Find all async slices whoes name are in the name list, and record the list of slices in time order.
  function getAllAsyncSlices(thread, name) {  
    var result = [];
  	thread.asyncSliceGroup.slices.forEach(function(slice) {
      if (name.indexOf(slice.title) > -1) {
  		result.push(slice);
  	  }
  	});
	result.sort(function(a, b) {return a.start-b.start}); 
  	return result;
  }
  
  // Find all slices of the given name.
  function getAllSlices(thread, name) {  
  	var result = [];
	thread.sliceGroup.slices.forEach(function(slice) {
      if (slice.title.indexOf(name) > -1) {
		result.push(slice);
	  }
	});
	return result;
  }
  
  function getHandlingTime(model, id) {
  	var handlers = {};
	var ackStatus;
    model.flowEvents.forEach(function(flow) {
	    // Follow the FlowEvent which starts from a touch event until we find its ack.
		if (flow.args.trace_id == id) {
		  var slice = flow.endSlice;
		  var ackSource;
		  while (slice !=null) {
			for (var i = 0; i < slice.ancestorSlices.length; i++) {
			  if (slice.ancestorSlices[i].title.indexOf('InputRouterImpl::ProcessInputEventAck') > -1) {
			  	console.log(slice.ancestorSlices[i].title + ' ' + slice.ancestorSlices[i].args.type + ' ' + slice.ancestorSlices[i].args.ack + ' ' + ackSource + ' ' + slice.ancestorSlices[i].start);
				ackStatus = slice.ancestorSlices[i].args.ack;
				return {
	              ackStatus: ackStatus,
	              ackSource: ackSource
	            };
			  }
			}
			
			// Find where sends the ack, we only care about ack from renderer.
			ackSource = slice.parentContainer.name;
			if (slice.outFlowEvents[0] != null)
			  slice = slice.outFlowEvents[0].endSlice;
			else
			  slice = null;
		  }
		}
	});
  }
  
  function allBlockingTimeMapFunction(model) {
  	var touchStartTime = {};
  	var browserThread = model.findAllThreadsNamed('CrBrowserMain');
	if (browserThread.length == 1) {	
	  var gestureScrollBegins = getAllAsyncSlices(browserThread[0], 'InputLatency::GestureScrollBegin');
	  console.log(gestureScrollBegins.length);
  	  for (var i = 0; i < gestureScrollBegins.length; i++) {
		console.log(gestureScrollBegins[i].title + ' ' + gestureScrollBegins[i].args.data.trace_id);
	  }
	  
	  var touchEvent = ['InputLatency::TouchStart']; // , 'InputLatency::TouchMove'
	  var touchEventSlices = getAllAsyncSlices(browserThread[0], touchEvent);
	  console.log(touchEventSlices.length);
  	  for (var i = 0; i < touchEventSlices.length; i++) {
		console.log(touchEventSlices[i].title + ' ' + touchEventSlices[i].args.data.trace_id + ' ' + touchEventSlices[i].start);
		getHandlingTime(model, touchEventSlices[i].args.data.trace_id);
	  }
	  
	  
 	}
	
	
	// InputRouterImpl::ProcessInputEventAck
	// touchStartTime[eventAck[i].Args.type] = eventAck[i].Args.ack;
	
  	return touchStartTime;
  }

  return {
    allBlockingTimeMapFunction: allBlockingTimeMapFunction
  };
});
</script>

