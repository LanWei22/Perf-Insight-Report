<!DOCTYPE HTML>

<link rel="import" href="/perf_insights/function_handle.html">
<link rel="import" href="/perf_insights/mappers/thread_grouping.html">
<link rel="import" href="/tracing/base/range.html">
<link rel="import" href="/tracing/value/histogram.html">
<link rel="import" href="/tracing/value/unit.html">

<script>
'use strict';

tr.exportTo('pi.m', function() {

  // Find all async slices whoes name are in the name list, and record the list of slices in time order.
  function getAllAsyncSlices(thread, name) {  
    var result = [];
  	thread.asyncSliceGroup.slices.forEach(function(slice) {
      if (name.indexOf(slice.title) > -1) {
  		result.push(slice);
  	  }
  	});
	result.sort(function(a, b) {return a.start-b.start}); 
  	return result;
  }
  
  // Find all slices of the given name.
  function getAckSlicesNamed(thread, name) {  
  	var result = [];
	thread.sliceGroup.slices.forEach(function(slice) {
      if (slice.title.indexOf('InputRouterImpl::ProcessInputEventAck') > -1) {
      	if (name.indexOf(slice.args.type) > -1)
		  result.push(slice);
	  }
	});
	result.sort(function(a, b) {return a.start-b.start}); 
	return result;
  }

  function getTouchEventSlices(gestureSlices, touchEventSlices) {  
    var result = [];
    var j = 0;
    for (var i = 0; i < gestureSlices.length; i++) {
      for (; j < touchEventSlices.length; j++) {
      	if (gestureSlices[i].args.data.INPUT_EVENT_LATENCY_ORIGINAL_COMPONENT.time == touchEventSlices[j].args.data.INPUT_EVENT_LATENCY_ORIGINAL_COMPONENT.time) {
          result.push(touchEventSlices[j]);
          break;
        }
      }
    }
   	return result;
  }
  
  function allBlockingTimeMapFunction(model) {
  	var touchStartTime = {};
  	var browserThread = model.findAllThreadsNamed('CrBrowserMain');
	if (browserThread.length == 1) {
	  var touchEvents = ['InputLatency::TouchStart', 'InputLatency::TouchMove'];
	  var touchEventSlices = getAllAsyncSlices(browserThread[0], touchEvents);
	  console.log(touchEventSlices.length);
	  for (var i = 0; i < touchEventSlices.length; i++) {
		console.log(touchEventSlices[i].title + ' ' + touchEventSlices[i].start);
	  }
      
      var touchTypes = ['TouchStart', 'TouchMove'];
      var ackSlices = getAckSlicesNamed(browserThread[0], touchTypes);
	  console.log(ackSlices.length);
  	  for (var i = 0; i < ackSlices.length; i++) {
		console.log(ackSlices[i].title + ' ' + ackSlices[i].args.type + ' ' + ackSlices[i].args.ack + ' ' + ackSlices[i].start);
	  }
	  
	  
 	}
	
	
	// InputRouterImpl::ProcessInputEventAck
	// touchStartTime[eventAck[i].args.type] = eventAck[i].args.ack;
	
  	return touchStartTime;
  }

  return {
    allBlockingTimeMapFunction: allBlockingTimeMapFunction
  };
});
</script>

